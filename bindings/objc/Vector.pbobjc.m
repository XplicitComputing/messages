// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vector.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Vector.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(Revision);

#pragma mark - VectorRoot

@implementation VectorRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - VectorRoot_FileDescriptor

static GPBFileDescriptor *VectorRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"Messages"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Revision

@implementation Revision

@dynamic majorRev;
@dynamic minorRev;

typedef struct Revision__storage_ {
  uint32_t _has_storage_[1];
  int64_t majorRev;
  int64_t minorRev;
} Revision__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "majorRev",
        .dataTypeSpecific.clazz = Nil,
        .number = Revision_FieldNumber_MajorRev,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Revision__storage_, majorRev),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "minorRev",
        .dataTypeSpecific.clazz = Nil,
        .number = Revision_FieldNumber_MinorRev,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Revision__storage_, minorRev),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Revision class]
                                     rootClass:[VectorRoot class]
                                          file:VectorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Revision__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Extrema

@implementation Extrema

@dynamic dims;
@dynamic minArray, minArray_Count;
@dynamic maxArray, maxArray_Count;
@dynamic isSet;

typedef struct Extrema__storage_ {
  uint32_t _has_storage_[1];
  int32_t dims;
  GPBDoubleArray *minArray;
  GPBDoubleArray *maxArray;
} Extrema__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dims",
        .dataTypeSpecific.clazz = Nil,
        .number = Extrema_FieldNumber_Dims,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Extrema__storage_, dims),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "minArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Extrema_FieldNumber_MinArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Extrema__storage_, minArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "maxArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Extrema_FieldNumber_MaxArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Extrema__storage_, maxArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "isSet",
        .dataTypeSpecific.clazz = Nil,
        .number = Extrema_FieldNumber_IsSet,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Extrema class]
                                     rootClass:[VectorRoot class]
                                          file:VectorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Extrema__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Vector32

@implementation Vector32

@dynamic name;
@dynamic components;
@dynamic interleaved;
@dynamic hasRevision, revision;
@dynamic units;
@dynamic valuesArray, valuesArray_Count;

typedef struct Vector32__storage_ {
  uint32_t _has_storage_[1];
  int32_t components;
  NSString *name;
  Revision *revision;
  NSString *units;
  GPBFloatArray *valuesArray;
} Vector32__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = Vector32_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Vector32__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "components",
        .dataTypeSpecific.clazz = Nil,
        .number = Vector32_FieldNumber_Components,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Vector32__storage_, components),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "interleaved",
        .dataTypeSpecific.clazz = Nil,
        .number = Vector32_FieldNumber_Interleaved,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "revision",
        .dataTypeSpecific.clazz = GPBObjCClass(Revision),
        .number = Vector32_FieldNumber_Revision,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Vector32__storage_, revision),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "units",
        .dataTypeSpecific.clazz = Nil,
        .number = Vector32_FieldNumber_Units,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Vector32__storage_, units),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "valuesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Vector32_FieldNumber_ValuesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Vector32__storage_, valuesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Vector32 class]
                                     rootClass:[VectorRoot class]
                                          file:VectorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Vector32__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Vector64

@implementation Vector64

@dynamic name;
@dynamic components;
@dynamic interleaved;
@dynamic hasRevision, revision;
@dynamic units;
@dynamic valuesArray, valuesArray_Count;

typedef struct Vector64__storage_ {
  uint32_t _has_storage_[1];
  int32_t components;
  NSString *name;
  Revision *revision;
  NSString *units;
  GPBDoubleArray *valuesArray;
} Vector64__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = Vector64_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Vector64__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "components",
        .dataTypeSpecific.clazz = Nil,
        .number = Vector64_FieldNumber_Components,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Vector64__storage_, components),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "interleaved",
        .dataTypeSpecific.clazz = Nil,
        .number = Vector64_FieldNumber_Interleaved,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "revision",
        .dataTypeSpecific.clazz = GPBObjCClass(Revision),
        .number = Vector64_FieldNumber_Revision,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Vector64__storage_, revision),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "units",
        .dataTypeSpecific.clazz = Nil,
        .number = Vector64_FieldNumber_Units,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Vector64__storage_, units),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "valuesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Vector64_FieldNumber_ValuesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Vector64__storage_, valuesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Vector64 class]
                                     rootClass:[VectorRoot class]
                                          file:VectorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Vector64__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Indices

@implementation Indices

@dynamic name;
@dynamic valuesArray, valuesArray_Count;

typedef struct Indices__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  GPBInt32Array *valuesArray;
} Indices__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = Indices_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Indices__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "valuesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Indices_FieldNumber_ValuesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Indices__storage_, valuesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Indices class]
                                     rootClass:[VectorRoot class]
                                          file:VectorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Indices__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Elements

@implementation Elements

@dynamic indicesArray, indicesArray_Count;
@dynamic stridesArray, stridesArray_Count;
@dynamic offsetsArray, offsetsArray_Count;
@dynamic typesArray, typesArray_Count;
@dynamic idsArray, idsArray_Count;
@dynamic idOffsetsArray, idOffsetsArray_Count;
@dynamic numElementsWithIdArray, numElementsWithIdArray_Count;
@dynamic idToIndexArray, idToIndexArray_Count;
@dynamic flagsArray, flagsArray_Count;
@dynamic centersArray, centersArray_Count;
@dynamic lengthsArray, lengthsArray_Count;
@dynamic areasArray, areasArray_Count;
@dynamic volumesArray, volumesArray_Count;

typedef struct Elements__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32Array *indicesArray;
  GPBInt32Array *stridesArray;
  GPBInt32Array *offsetsArray;
  GPBInt32Array *typesArray;
  GPBInt32Array *idsArray;
  GPBInt32Array *idOffsetsArray;
  GPBInt32Array *numElementsWithIdArray;
  GPBInt32Array *idToIndexArray;
  GPBInt32Array *flagsArray;
  GPBDoubleArray *centersArray;
  GPBDoubleArray *lengthsArray;
  GPBDoubleArray *areasArray;
  GPBDoubleArray *volumesArray;
} Elements__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "indicesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Elements_FieldNumber_IndicesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Elements__storage_, indicesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "stridesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Elements_FieldNumber_StridesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Elements__storage_, stridesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "offsetsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Elements_FieldNumber_OffsetsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Elements__storage_, offsetsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "typesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Elements_FieldNumber_TypesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Elements__storage_, typesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "idsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Elements_FieldNumber_IdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Elements__storage_, idsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "idOffsetsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Elements_FieldNumber_IdOffsetsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Elements__storage_, idOffsetsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "numElementsWithIdArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Elements_FieldNumber_NumElementsWithIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Elements__storage_, numElementsWithIdArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "idToIndexArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Elements_FieldNumber_IdToIndexArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Elements__storage_, idToIndexArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "flagsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Elements_FieldNumber_FlagsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Elements__storage_, flagsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "centersArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Elements_FieldNumber_CentersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Elements__storage_, centersArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "lengthsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Elements_FieldNumber_LengthsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Elements__storage_, lengthsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "areasArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Elements_FieldNumber_AreasArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Elements__storage_, areasArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "volumesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Elements_FieldNumber_VolumesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Elements__storage_, volumesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Elements class]
                                     rootClass:[VectorRoot class]
                                          file:VectorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Elements__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
