// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: spatial.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Spatial.pbobjc.h"
#import "Vector.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(Elements);
GPBObjCClassDeclaration(Extrema);
GPBObjCClassDeclaration(Revision);
GPBObjCClassDeclaration(Vector64);
GPBObjCClassDeclaration(Zone);

#pragma mark - SpatialRoot

@implementation SpatialRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - SpatialRoot_FileDescriptor

static GPBFileDescriptor *SpatialRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"Messages"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Zone

@implementation Zone

@dynamic name;
@dynamic id_p;
@dynamic dimensionality;
@dynamic numElements;
@dynamic offset;
@dynamic comments;
@dynamic info;
@dynamic hasBounds, bounds;
@dynamic terminalPositionArray, terminalPositionArray_Count;
@dynamic specificElementsArray, specificElementsArray_Count;

typedef struct Zone__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t dimensionality;
  NSString *name;
  NSString *comments;
  NSString *info;
  Extrema *bounds;
  GPBFloatArray *terminalPositionArray;
  GPBInt32Array *specificElementsArray;
  int64_t numElements;
  int64_t offset;
} Zone__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = Zone_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Zone__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = Zone_FieldNumber_Id_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Zone__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "dimensionality",
        .dataTypeSpecific.clazz = Nil,
        .number = Zone_FieldNumber_Dimensionality,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Zone__storage_, dimensionality),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "numElements",
        .dataTypeSpecific.clazz = Nil,
        .number = Zone_FieldNumber_NumElements,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Zone__storage_, numElements),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = Zone_FieldNumber_Offset,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Zone__storage_, offset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "comments",
        .dataTypeSpecific.clazz = Nil,
        .number = Zone_FieldNumber_Comments,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Zone__storage_, comments),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "info",
        .dataTypeSpecific.clazz = Nil,
        .number = Zone_FieldNumber_Info,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Zone__storage_, info),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bounds",
        .dataTypeSpecific.clazz = GPBObjCClass(Extrema),
        .number = Zone_FieldNumber_Bounds,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Zone__storage_, bounds),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "terminalPositionArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Zone_FieldNumber_TerminalPositionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Zone__storage_, terminalPositionArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "specificElementsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Zone_FieldNumber_SpecificElementsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Zone__storage_, specificElementsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Zone class]
                                     rootClass:[SpatialRoot class]
                                          file:SpatialRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Zone__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Topology

@implementation Topology

@dynamic name;
@dynamic type;
@dynamic ndim;
@dynamic basis;
@dynamic resolutionArray, resolutionArray_Count;
@dynamic dataArray, dataArray_Count;
@dynamic hasNodes, nodes;
@dynamic hasEdges, edges;
@dynamic hasInteriorEdges, interiorEdges;
@dynamic hasFaces, faces;
@dynamic hasInteriorFaces, interiorFaces;
@dynamic hasCells, cells;
@dynamic groupsArray, groupsArray_Count;
@dynamic loopsArray, loopsArray_Count;
@dynamic surfacesArray, surfacesArray_Count;
@dynamic volumesArray, volumesArray_Count;
@dynamic locationsArray, locationsArray_Count;
@dynamic filename;
@dynamic hasRevision, revision;

typedef struct Topology__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  int32_t ndim;
  int32_t basis;
  NSString *name;
  GPBDoubleArray *resolutionArray;
  NSMutableArray *dataArray;
  Elements *nodes;
  Elements *edges;
  Elements *interiorEdges;
  Elements *faces;
  Elements *interiorFaces;
  Elements *cells;
  NSMutableArray *groupsArray;
  NSMutableArray *loopsArray;
  NSMutableArray *surfacesArray;
  NSMutableArray *volumesArray;
  GPBInt32Array *locationsArray;
  NSString *filename;
  Revision *revision;
} Topology__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = Topology_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Topology__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.clazz = Nil,
        .number = Topology_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Topology__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "ndim",
        .dataTypeSpecific.clazz = Nil,
        .number = Topology_FieldNumber_Ndim,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Topology__storage_, ndim),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "basis",
        .dataTypeSpecific.clazz = Nil,
        .number = Topology_FieldNumber_Basis,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Topology__storage_, basis),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "resolutionArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Topology_FieldNumber_ResolutionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Topology__storage_, resolutionArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "dataArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Vector64),
        .number = Topology_FieldNumber_DataArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Topology__storage_, dataArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nodes",
        .dataTypeSpecific.clazz = GPBObjCClass(Elements),
        .number = Topology_FieldNumber_Nodes,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Topology__storage_, nodes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "edges",
        .dataTypeSpecific.clazz = GPBObjCClass(Elements),
        .number = Topology_FieldNumber_Edges,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Topology__storage_, edges),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "interiorEdges",
        .dataTypeSpecific.clazz = GPBObjCClass(Elements),
        .number = Topology_FieldNumber_InteriorEdges,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Topology__storage_, interiorEdges),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "faces",
        .dataTypeSpecific.clazz = GPBObjCClass(Elements),
        .number = Topology_FieldNumber_Faces,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Topology__storage_, faces),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "interiorFaces",
        .dataTypeSpecific.clazz = GPBObjCClass(Elements),
        .number = Topology_FieldNumber_InteriorFaces,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Topology__storage_, interiorFaces),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cells",
        .dataTypeSpecific.clazz = GPBObjCClass(Elements),
        .number = Topology_FieldNumber_Cells,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Topology__storage_, cells),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Zone),
        .number = Topology_FieldNumber_GroupsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Topology__storage_, groupsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "loopsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Zone),
        .number = Topology_FieldNumber_LoopsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Topology__storage_, loopsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "surfacesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Zone),
        .number = Topology_FieldNumber_SurfacesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Topology__storage_, surfacesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "volumesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Zone),
        .number = Topology_FieldNumber_VolumesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Topology__storage_, volumesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "locationsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Topology_FieldNumber_LocationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Topology__storage_, locationsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "filename",
        .dataTypeSpecific.clazz = Nil,
        .number = Topology_FieldNumber_Filename,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Topology__storage_, filename),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "revision",
        .dataTypeSpecific.clazz = GPBObjCClass(Revision),
        .number = Topology_FieldNumber_Revision,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Topology__storage_, revision),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Topology class]
                                     rootClass:[SpatialRoot class]
                                          file:SpatialRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Topology__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GridControl

@implementation GridControl

@dynamic basis;
@dynamic sizeArray, sizeArray_Count;
@dynamic spacingArray, spacingArray_Count;
@dynamic gradingArray, gradingArray_Count;
@dynamic hasBounds, bounds;

typedef struct GridControl__storage_ {
  uint32_t _has_storage_[1];
  int32_t basis;
  GPBInt32Array *sizeArray;
  GPBDoubleArray *spacingArray;
  GPBDoubleArray *gradingArray;
  Extrema *bounds;
} GridControl__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "basis",
        .dataTypeSpecific.clazz = Nil,
        .number = GridControl_FieldNumber_Basis,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GridControl__storage_, basis),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sizeArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GridControl_FieldNumber_SizeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GridControl__storage_, sizeArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "spacingArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GridControl_FieldNumber_SpacingArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GridControl__storage_, spacingArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "gradingArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GridControl_FieldNumber_GradingArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GridControl__storage_, gradingArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "bounds",
        .dataTypeSpecific.clazz = GPBObjCClass(Extrema),
        .number = GridControl_FieldNumber_Bounds,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GridControl__storage_, bounds),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GridControl class]
                                     rootClass:[SpatialRoot class]
                                          file:SpatialRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GridControl__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MeshControl

@implementation MeshControl

@dynamic targetN;
@dynamic maxIterations;
@dynamic sizeRatio;
@dynamic sizeDecay;
@dynamic sizeExponent;
@dynamic curvRatio;
@dynamic curvDecay;
@dynamic curvExponent;
@dynamic nodeRadius;
@dynamic hasBounds, bounds;
@dynamic interior;
@dynamic exterior;
@dynamic shell;
@dynamic equalize;
@dynamic smooth;
@dynamic includeBackground;
@dynamic keepExistingPoints;
@dynamic xSymmetry;
@dynamic ySymmetry;
@dynamic zSymmetry;
@dynamic backgroundN;

typedef struct MeshControl__storage_ {
  uint32_t _has_storage_[1];
  int32_t maxIterations;
  Extrema *bounds;
  int64_t targetN;
  double sizeRatio;
  double sizeDecay;
  double sizeExponent;
  double curvRatio;
  double curvDecay;
  double curvExponent;
  double nodeRadius;
  int64_t backgroundN;
} MeshControl__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetN",
        .dataTypeSpecific.clazz = Nil,
        .number = MeshControl_FieldNumber_TargetN,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MeshControl__storage_, targetN),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "maxIterations",
        .dataTypeSpecific.clazz = Nil,
        .number = MeshControl_FieldNumber_MaxIterations,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MeshControl__storage_, maxIterations),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sizeRatio",
        .dataTypeSpecific.clazz = Nil,
        .number = MeshControl_FieldNumber_SizeRatio,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MeshControl__storage_, sizeRatio),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "sizeDecay",
        .dataTypeSpecific.clazz = Nil,
        .number = MeshControl_FieldNumber_SizeDecay,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MeshControl__storage_, sizeDecay),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "sizeExponent",
        .dataTypeSpecific.clazz = Nil,
        .number = MeshControl_FieldNumber_SizeExponent,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MeshControl__storage_, sizeExponent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "curvRatio",
        .dataTypeSpecific.clazz = Nil,
        .number = MeshControl_FieldNumber_CurvRatio,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(MeshControl__storage_, curvRatio),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "curvDecay",
        .dataTypeSpecific.clazz = Nil,
        .number = MeshControl_FieldNumber_CurvDecay,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(MeshControl__storage_, curvDecay),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "curvExponent",
        .dataTypeSpecific.clazz = Nil,
        .number = MeshControl_FieldNumber_CurvExponent,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(MeshControl__storage_, curvExponent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "nodeRadius",
        .dataTypeSpecific.clazz = Nil,
        .number = MeshControl_FieldNumber_NodeRadius,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(MeshControl__storage_, nodeRadius),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "bounds",
        .dataTypeSpecific.clazz = GPBObjCClass(Extrema),
        .number = MeshControl_FieldNumber_Bounds,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(MeshControl__storage_, bounds),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "interior",
        .dataTypeSpecific.clazz = Nil,
        .number = MeshControl_FieldNumber_Interior,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "exterior",
        .dataTypeSpecific.clazz = Nil,
        .number = MeshControl_FieldNumber_Exterior,
        .hasIndex = 12,
        .offset = 13,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "shell",
        .dataTypeSpecific.clazz = Nil,
        .number = MeshControl_FieldNumber_Shell,
        .hasIndex = 14,
        .offset = 15,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "equalize",
        .dataTypeSpecific.clazz = Nil,
        .number = MeshControl_FieldNumber_Equalize,
        .hasIndex = 16,
        .offset = 17,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "smooth",
        .dataTypeSpecific.clazz = Nil,
        .number = MeshControl_FieldNumber_Smooth,
        .hasIndex = 18,
        .offset = 19,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "includeBackground",
        .dataTypeSpecific.clazz = Nil,
        .number = MeshControl_FieldNumber_IncludeBackground,
        .hasIndex = 20,
        .offset = 21,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "keepExistingPoints",
        .dataTypeSpecific.clazz = Nil,
        .number = MeshControl_FieldNumber_KeepExistingPoints,
        .hasIndex = 22,
        .offset = 23,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "xSymmetry",
        .dataTypeSpecific.clazz = Nil,
        .number = MeshControl_FieldNumber_XSymmetry,
        .hasIndex = 24,
        .offset = 25,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "ySymmetry",
        .dataTypeSpecific.clazz = Nil,
        .number = MeshControl_FieldNumber_YSymmetry,
        .hasIndex = 26,
        .offset = 27,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "zSymmetry",
        .dataTypeSpecific.clazz = Nil,
        .number = MeshControl_FieldNumber_ZSymmetry,
        .hasIndex = 28,
        .offset = 29,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "backgroundN",
        .dataTypeSpecific.clazz = Nil,
        .number = MeshControl_FieldNumber_BackgroundN,
        .hasIndex = 30,
        .offset = (uint32_t)offsetof(MeshControl__storage_, backgroundN),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MeshControl class]
                                     rootClass:[SpatialRoot class]
                                          file:SpatialRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MeshControl__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TreeControl

@implementation TreeControl

@dynamic minDepth;
@dynamic maxDepth;
@dynamic maxSize;
@dynamic hasBounds, bounds;

typedef struct TreeControl__storage_ {
  uint32_t _has_storage_[1];
  int32_t minDepth;
  int32_t maxDepth;
  Extrema *bounds;
  int64_t maxSize;
} TreeControl__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "minDepth",
        .dataTypeSpecific.clazz = Nil,
        .number = TreeControl_FieldNumber_MinDepth,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TreeControl__storage_, minDepth),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxDepth",
        .dataTypeSpecific.clazz = Nil,
        .number = TreeControl_FieldNumber_MaxDepth,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TreeControl__storage_, maxDepth),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxSize",
        .dataTypeSpecific.clazz = Nil,
        .number = TreeControl_FieldNumber_MaxSize,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TreeControl__storage_, maxSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "bounds",
        .dataTypeSpecific.clazz = GPBObjCClass(Extrema),
        .number = TreeControl_FieldNumber_Bounds,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TreeControl__storage_, bounds),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TreeControl class]
                                     rootClass:[SpatialRoot class]
                                          file:SpatialRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TreeControl__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkControl

@implementation NetworkControl


typedef struct NetworkControl__storage_ {
  uint32_t _has_storage_[1];
} NetworkControl__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkControl class]
                                     rootClass:[SpatialRoot class]
                                          file:SpatialRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(NetworkControl__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
