// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: system.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "System.pbobjc.h"
#import "Vector.pbobjc.h"
#import "Meta.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(Command);
GPBObjCClassDeclaration(Function);
GPBObjCClassDeclaration(Meta);
GPBObjCClassDeclaration(Model);
GPBObjCClassDeclaration(Rule);
GPBObjCClassDeclaration(Script);
GPBObjCClassDeclaration(Variables);
GPBObjCClassDeclaration(Vector64);

#pragma mark - SystemRoot

@implementation SystemRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - SystemRoot_FileDescriptor

static GPBFileDescriptor *SystemRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"Messages"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Variables

@implementation Variables

@dynamic intNamesArray, intNamesArray_Count;
@dynamic intValuesArray, intValuesArray_Count;
@dynamic intDescriptionsArray, intDescriptionsArray_Count;
@dynamic boolNamesArray, boolNamesArray_Count;
@dynamic boolValuesArray, boolValuesArray_Count;
@dynamic boolDescriptionsArray, boolDescriptionsArray_Count;
@dynamic doubleNamesArray, doubleNamesArray_Count;
@dynamic doubleValuesArray, doubleValuesArray_Count;
@dynamic doubleDescriptionsArray, doubleDescriptionsArray_Count;
@dynamic stringNamesArray, stringNamesArray_Count;
@dynamic stringValuesArray, stringValuesArray_Count;
@dynamic stringDescriptionsArray, stringDescriptionsArray_Count;

typedef struct Variables__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *intNamesArray;
  GPBInt32Array *intValuesArray;
  NSMutableArray *intDescriptionsArray;
  NSMutableArray *boolNamesArray;
  GPBBoolArray *boolValuesArray;
  NSMutableArray *boolDescriptionsArray;
  NSMutableArray *doubleNamesArray;
  GPBDoubleArray *doubleValuesArray;
  NSMutableArray *doubleDescriptionsArray;
  NSMutableArray *stringNamesArray;
  NSMutableArray *stringValuesArray;
  NSMutableArray *stringDescriptionsArray;
} Variables__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "intNamesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Variables_FieldNumber_IntNamesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Variables__storage_, intNamesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "intValuesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Variables_FieldNumber_IntValuesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Variables__storage_, intValuesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "intDescriptionsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Variables_FieldNumber_IntDescriptionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Variables__storage_, intDescriptionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "boolNamesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Variables_FieldNumber_BoolNamesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Variables__storage_, boolNamesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "boolValuesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Variables_FieldNumber_BoolValuesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Variables__storage_, boolValuesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "boolDescriptionsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Variables_FieldNumber_BoolDescriptionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Variables__storage_, boolDescriptionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "doubleNamesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Variables_FieldNumber_DoubleNamesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Variables__storage_, doubleNamesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "doubleValuesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Variables_FieldNumber_DoubleValuesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Variables__storage_, doubleValuesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "doubleDescriptionsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Variables_FieldNumber_DoubleDescriptionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Variables__storage_, doubleDescriptionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "stringNamesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Variables_FieldNumber_StringNamesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Variables__storage_, stringNamesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "stringValuesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Variables_FieldNumber_StringValuesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Variables__storage_, stringValuesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "stringDescriptionsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Variables_FieldNumber_StringDescriptionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Variables__storage_, stringDescriptionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Variables class]
                                     rootClass:[SystemRoot class]
                                          file:SystemRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Variables__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Function

@implementation Function

@dynamic name;
@dynamic argumentTypesArray, argumentTypesArray_Count;
@dynamic argumentDescriptionsArray, argumentDescriptionsArray_Count;
@dynamic inputsArray, inputsArray_Count;
@dynamic outputsArray, outputsArray_Count;
@dynamic constantsArray, constantsArray_Count;
@dynamic toBeDefinedArray, toBeDefinedArray_Count;
@dynamic dataArray, dataArray_Count;
@dynamic cpuCapable;
@dynamic gpuCapable;
@dynamic includeAsPreprocessor;
@dynamic omitFromMainLoop;
@dynamic includeAsPostprocessor;
@dynamic mutuallyExclusive;
@dynamic onlyOnce;
@dynamic pushFront;
@dynamic dontFlatten;

typedef struct Function__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSMutableArray *argumentTypesArray;
  NSMutableArray *argumentDescriptionsArray;
  NSMutableArray *inputsArray;
  NSMutableArray *outputsArray;
  NSMutableArray *constantsArray;
  NSMutableArray *toBeDefinedArray;
  NSMutableArray *dataArray;
} Function__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = Function_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Function__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "argumentTypesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Function_FieldNumber_ArgumentTypesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Function__storage_, argumentTypesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "argumentDescriptionsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Function_FieldNumber_ArgumentDescriptionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Function__storage_, argumentDescriptionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "inputsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Function_FieldNumber_InputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Function__storage_, inputsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "outputsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Function_FieldNumber_OutputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Function__storage_, outputsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "constantsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Function_FieldNumber_ConstantsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Function__storage_, constantsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "toBeDefinedArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Function_FieldNumber_ToBeDefinedArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Function__storage_, toBeDefinedArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dataArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Vector64),
        .number = Function_FieldNumber_DataArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Function__storage_, dataArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cpuCapable",
        .dataTypeSpecific.clazz = Nil,
        .number = Function_FieldNumber_CpuCapable,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "gpuCapable",
        .dataTypeSpecific.clazz = Nil,
        .number = Function_FieldNumber_GpuCapable,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "includeAsPreprocessor",
        .dataTypeSpecific.clazz = Nil,
        .number = Function_FieldNumber_IncludeAsPreprocessor,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "omitFromMainLoop",
        .dataTypeSpecific.clazz = Nil,
        .number = Function_FieldNumber_OmitFromMainLoop,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "includeAsPostprocessor",
        .dataTypeSpecific.clazz = Nil,
        .number = Function_FieldNumber_IncludeAsPostprocessor,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "mutuallyExclusive",
        .dataTypeSpecific.clazz = Nil,
        .number = Function_FieldNumber_MutuallyExclusive,
        .hasIndex = 11,
        .offset = 12,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "onlyOnce",
        .dataTypeSpecific.clazz = Nil,
        .number = Function_FieldNumber_OnlyOnce,
        .hasIndex = 13,
        .offset = 14,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "pushFront",
        .dataTypeSpecific.clazz = Nil,
        .number = Function_FieldNumber_PushFront,
        .hasIndex = 15,
        .offset = 16,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "dontFlatten",
        .dataTypeSpecific.clazz = Nil,
        .number = Function_FieldNumber_DontFlatten,
        .hasIndex = 17,
        .offset = 18,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Function class]
                                     rootClass:[SystemRoot class]
                                          file:SystemRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Function__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Command

@implementation Command

@dynamic hasFunction, function;
@dynamic argsAreSet;
@dynamic kernelReady;
@dynamic execCount;
@dynamic effectiveSize;
@dynamic version;
@dynamic id_p;
@dynamic nKernel;
@dynamic progress;
@dynamic msg;
@dynamic dataArray, dataArray_Count;
@dynamic beforeArray, beforeArray_Count;
@dynamic afterArray, afterArray_Count;
@dynamic regionTypeArray, regionTypeArray_Count;
@dynamic regionIdArray, regionIdArray_Count;
@dynamic argumentTypesArray, argumentTypesArray_Count;
@dynamic argumentDescriptionsArray, argumentDescriptionsArray_Count;

typedef struct Command__storage_ {
  uint32_t _has_storage_[1];
  float progress;
  Function *function;
  NSString *msg;
  NSMutableArray *dataArray;
  NSMutableArray *beforeArray;
  NSMutableArray *afterArray;
  GPBInt32Array *regionTypeArray;
  GPBInt32Array *regionIdArray;
  NSMutableArray *argumentTypesArray;
  NSMutableArray *argumentDescriptionsArray;
  int64_t execCount;
  int64_t effectiveSize;
  int64_t version;
  int64_t id_p;
  int64_t nKernel;
} Command__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "function",
        .dataTypeSpecific.clazz = GPBObjCClass(Function),
        .number = Command_FieldNumber_Function,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Command__storage_, function),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "argsAreSet",
        .dataTypeSpecific.clazz = Nil,
        .number = Command_FieldNumber_ArgsAreSet,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "kernelReady",
        .dataTypeSpecific.clazz = Nil,
        .number = Command_FieldNumber_KernelReady,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "execCount",
        .dataTypeSpecific.clazz = Nil,
        .number = Command_FieldNumber_ExecCount,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Command__storage_, execCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "effectiveSize",
        .dataTypeSpecific.clazz = Nil,
        .number = Command_FieldNumber_EffectiveSize,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Command__storage_, effectiveSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = Command_FieldNumber_Version,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Command__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = Command_FieldNumber_Id_p,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Command__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "nKernel",
        .dataTypeSpecific.clazz = Nil,
        .number = Command_FieldNumber_NKernel,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Command__storage_, nKernel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "progress",
        .dataTypeSpecific.clazz = Nil,
        .number = Command_FieldNumber_Progress,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Command__storage_, progress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = Nil,
        .number = Command_FieldNumber_Msg,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Command__storage_, msg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dataArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Vector64),
        .number = Command_FieldNumber_DataArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Command__storage_, dataArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "beforeArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Command),
        .number = Command_FieldNumber_BeforeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Command__storage_, beforeArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "afterArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Command),
        .number = Command_FieldNumber_AfterArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Command__storage_, afterArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "regionTypeArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Command_FieldNumber_RegionTypeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Command__storage_, regionTypeArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "regionIdArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Command_FieldNumber_RegionIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Command__storage_, regionIdArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "argumentTypesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Command_FieldNumber_ArgumentTypesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Command__storage_, argumentTypesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "argumentDescriptionsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Command_FieldNumber_ArgumentDescriptionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Command__storage_, argumentDescriptionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Command class]
                                     rootClass:[SystemRoot class]
                                          file:SystemRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Command__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Script

@implementation Script

@dynamic name;
@dynamic msg;
@dynamic sourceCode;
@dynamic uid;
@dynamic device;
@dynamic status;
@dynamic order;
@dynamic progress;
@dynamic hasVariables, variables;
@dynamic sequenceArray, sequenceArray_Count;
@dynamic hasBefore, before;
@dynamic hasAfter, after;

typedef struct Script__storage_ {
  uint32_t _has_storage_[1];
  int32_t device;
  int32_t status;
  int32_t order;
  float progress;
  NSString *name;
  NSString *msg;
  NSString *sourceCode;
  Variables *variables;
  NSMutableArray *sequenceArray;
  Script *before;
  Script *after;
  int64_t uid;
} Script__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = Script_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Script__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = Nil,
        .number = Script_FieldNumber_Msg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Script__storage_, msg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sourceCode",
        .dataTypeSpecific.clazz = Nil,
        .number = Script_FieldNumber_SourceCode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Script__storage_, sourceCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uid",
        .dataTypeSpecific.clazz = Nil,
        .number = Script_FieldNumber_Uid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Script__storage_, uid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "device",
        .dataTypeSpecific.clazz = Nil,
        .number = Script_FieldNumber_Device,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Script__storage_, device),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "status",
        .dataTypeSpecific.clazz = Nil,
        .number = Script_FieldNumber_Status,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Script__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "order",
        .dataTypeSpecific.clazz = Nil,
        .number = Script_FieldNumber_Order,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Script__storage_, order),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "progress",
        .dataTypeSpecific.clazz = Nil,
        .number = Script_FieldNumber_Progress,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Script__storage_, progress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "variables",
        .dataTypeSpecific.clazz = GPBObjCClass(Variables),
        .number = Script_FieldNumber_Variables,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Script__storage_, variables),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sequenceArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Command),
        .number = Script_FieldNumber_SequenceArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Script__storage_, sequenceArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "before",
        .dataTypeSpecific.clazz = GPBObjCClass(Script),
        .number = Script_FieldNumber_Before,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Script__storage_, before),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "after",
        .dataTypeSpecific.clazz = GPBObjCClass(Script),
        .number = Script_FieldNumber_After,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Script__storage_, after),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Script class]
                                     rootClass:[SystemRoot class]
                                          file:SystemRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Script__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Rule

@implementation Rule

@dynamic pk;
@dynamic algorithmsArray, algorithmsArray_Count;
@dynamic priorityArray, priorityArray_Count;

typedef struct Rule__storage_ {
  uint32_t _has_storage_[1];
  NSString *pk;
  NSMutableArray *algorithmsArray;
  GPBInt32Array *priorityArray;
} Rule__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pk",
        .dataTypeSpecific.clazz = Nil,
        .number = Rule_FieldNumber_Pk,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Rule__storage_, pk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "algorithmsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Rule_FieldNumber_AlgorithmsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Rule__storage_, algorithmsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "priorityArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Rule_FieldNumber_PriorityArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Rule__storage_, priorityArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Rule class]
                                     rootClass:[SystemRoot class]
                                          file:SystemRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Rule__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Model

@implementation Model

@dynamic name;
@dynamic dofsArray, dofsArray_Count;
@dynamic algorithmsArray, algorithmsArray_Count;
@dynamic availableOutputsArray, availableOutputsArray_Count;
@dynamic extraPropertiesArray, extraPropertiesArray_Count;
@dynamic compatibleConditionsArray, compatibleConditionsArray_Count;
@dynamic compatibleScriptsArray, compatibleScriptsArray_Count;
@dynamic subModelsArray, subModelsArray_Count;
@dynamic dataArray, dataArray_Count;
@dynamic rulesArray, rulesArray_Count;
@dynamic mutexStackArray, mutexStackArray_Count;

typedef struct Model__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSMutableArray *dofsArray;
  NSMutableArray *algorithmsArray;
  NSMutableArray *availableOutputsArray;
  NSMutableArray *extraPropertiesArray;
  NSMutableArray *compatibleConditionsArray;
  NSMutableArray *compatibleScriptsArray;
  NSMutableArray *subModelsArray;
  NSMutableArray *dataArray;
  NSMutableArray *rulesArray;
  NSMutableArray *mutexStackArray;
} Model__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = Model_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Model__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dofsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Model_FieldNumber_DofsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Model__storage_, dofsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "algorithmsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Model_FieldNumber_AlgorithmsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Model__storage_, algorithmsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "availableOutputsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Model_FieldNumber_AvailableOutputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Model__storage_, availableOutputsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extraPropertiesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Model_FieldNumber_ExtraPropertiesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Model__storage_, extraPropertiesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "compatibleConditionsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Model_FieldNumber_CompatibleConditionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Model__storage_, compatibleConditionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "compatibleScriptsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Model_FieldNumber_CompatibleScriptsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Model__storage_, compatibleScriptsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "subModelsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Model),
        .number = Model_FieldNumber_SubModelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Model__storage_, subModelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dataArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Vector64),
        .number = Model_FieldNumber_DataArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Model__storage_, dataArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rulesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Rule),
        .number = Model_FieldNumber_RulesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Model__storage_, rulesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mutexStackArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Rule),
        .number = Model_FieldNumber_MutexStackArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Model__storage_, mutexStackArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Model class]
                                     rootClass:[SystemRoot class]
                                          file:SystemRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Model__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - System

@implementation System

@dynamic hasMeta, meta;
@dynamic hasScript, script;
@dynamic geometry;
@dynamic modelsArray, modelsArray_Count;
@dynamic constantsArray, constantsArray_Count;
@dynamic conditionsArray, conditionsArray_Count;
@dynamic childrenArray, childrenArray_Count;
@dynamic referencesArray, referencesArray_Count;
@dynamic attachmentsArray, attachmentsArray_Count;

typedef struct System__storage_ {
  uint32_t _has_storage_[1];
  Meta *meta;
  Script *script;
  NSString *geometry;
  NSMutableArray *modelsArray;
  NSMutableArray *constantsArray;
  NSMutableArray *conditionsArray;
  NSMutableArray *childrenArray;
  NSMutableArray *referencesArray;
  NSMutableArray *attachmentsArray;
} System__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "meta",
        .dataTypeSpecific.clazz = GPBObjCClass(Meta),
        .number = System_FieldNumber_Meta,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(System__storage_, meta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "script",
        .dataTypeSpecific.clazz = GPBObjCClass(Script),
        .number = System_FieldNumber_Script,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(System__storage_, script),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "geometry",
        .dataTypeSpecific.clazz = Nil,
        .number = System_FieldNumber_Geometry,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(System__storage_, geometry),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "modelsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Model),
        .number = System_FieldNumber_ModelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(System__storage_, modelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "constantsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Vector64),
        .number = System_FieldNumber_ConstantsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(System__storage_, constantsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "conditionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Command),
        .number = System_FieldNumber_ConditionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(System__storage_, conditionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "childrenArray",
        .dataTypeSpecific.clazz = Nil,
        .number = System_FieldNumber_ChildrenArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(System__storage_, childrenArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "referencesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = System_FieldNumber_ReferencesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(System__storage_, referencesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "attachmentsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = System_FieldNumber_AttachmentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(System__storage_, attachmentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[System class]
                                     rootClass:[SystemRoot class]
                                          file:SystemRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(System__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
