#!/bin/bash


####################################
##
##  IMPORTANT:  must drop repeated patterns
##
##      ..so:   $> ./pgm | grep "FuncName" | sort | uniq
##
##
##  ..On function-names!!
##
####################################
#
#  Assumptions:
#
#   - assumes file contains a class
#   - if file contains a struct instead, will have to adapt, b/c default for structs w/o qualification is 'public' (unlike classes, which is 'private').
#
####################################


## Debug.. ##
debug=false


pgm=$(echo $0 | xargs basename)
if [[ "$#" -eq 0 ]]; then
    echo "[${pgm}]: Too Few Arguments!"
    exit 1
fi

filepath="."
if [[ "$#" -gt 1 ]]; then
    if grep -q "^--path=" <<< "$2"; then
        srcfile=$2
        filepath="${srcfile:7}"
    else
        echo "[${pgm}]: Bad Argument Value!"
        exit 1
    fi
fi

if [[ "$1" != "--server" ]] && [[ "$1" != "--client" ]]; then
    echo "[${pgm}]: Bad Argument Value!"
    exit 1
fi
if [[ "$1" == "--server" ]]; then
    file=${filepath}/"server.hpp"
    ctor="Server"
    dtor="~${ctor}"
elif [[ "$1" == "--client" ]]; then
    file="${filepath}/client.hpp"
    ctor="Client"
    dtor="~${ctor}"
fi
do_echo=false
do_block=false
while IFS= read -r line
do
    # trim leading|trailing spaces
    line=$(echo -e "${line}" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')

    # --


    # only read public-interface functions
    if [[ "$line" == "public:" ]] || [[ "$line" == "public :" ]]; then
        do_echo=true
        continue
    elif [[ "$line" == "protected:" ]] || [[ "$line" == "protected :" ]] || [[ "$line" == "private:" ]] || [[ "$line" == "private :" ]]; then
        do_echo=false
        continue
    fi

    # skip over functions not part of the public-interface
    if [[ "$do_echo" == "false" ]]; then
        continue
    fi


    # --


    # trap function blocks and lambdas
    if [[ "$line" == "{" ]] && [[ "$do_echo" == "true" ]]; then
        do_block=true
        continue
    elif [[ "$line" == "}" ]] || [[ "$line" == "};" ]]; then
        do_block=false
        continue
    fi

    # skip over function blocks and lambdas
    if [[ "$do_block" == "true" ]]; then
        continue
    fi


    # --


    ## Debug.. ##
    if [[ "$debug" == "true" ]]; then
        echo $line
        echo
    fi


    # filter only functions with a std::string parameter as first argument
    if [[ "$1" == "--server" ]]; then
        line=`echo "$line"  | grep -v "^//" \
                            | grep -E "\(string|\(const string|\(std::string|\(const std::string|\(size_t|\(std::size_t|\(long|\(std::int64_t|\(int|\(bool|\(std::list<std::int64_t>|\(Messages::|\(const Messages::|\(Surfaces|\(const Surfaces|\(const xc::messages::Log|\()|\( )" \
                            | grep -vE "^${ctor}\(|^${ctor} \(" \
                            | grep -vE "^${dtor}\(|^${dtor} \(" \
                            | grep -v \bauto\b \
                            | grep -v \boperator\b \
                            | grep -v operator\( \
                            | grep -v "\](" \
                            | grep -v "\]{" \
                            | grep -v "^if " \
                            | grep -v "^if(" \
                            | grep -v "^this->" \
                            | grep -v "*" \
                            | grep -vE "\(shared_ptr|\(std::shared_ptr" \
                            | grep -iv " info(" \
                            | grep -iv " process(" \
                            | grep -iv " processarg(" \
                            | grep -iv "<system> getsystem(" \
                            | grep -iv " compatibleConditions(" \
                            | grep -iv " cache_uid_cxn_pair("`
    elif [[ "$1" == "--client" ]]; then
        line=`echo "$line"  | grep -v "^//" \
                            | grep -E "\(Metaobject*|\(const Metaobject *|\(std::list<Metaobject *|\(Messages::|\(const Messages::|\(std::int64_t|\(int|\()|\( )" \
                            | grep -vE "^${ctor}\(|^${ctor} \(" \
                            | grep -vE "^${dtor}\(|^${dtor} \(" \
                            | grep -v \bauto\b \
                            | grep -v \boperator\b \
                            | grep -v operator\( \
                            | grep -v "\](" \
                            | grep -v "\]{" \
                            | grep -v "^if " \
                            | grep -v "^if(" \
                            | grep -v "^this->" \
                            | grep -iv " openexternally" \
                            | grep -iv " info("`
    fi


    ## Debug.. ##
    if [[ "$debug" == "true" ]]; then
        echo ">>> $line"
    fi


    # echo non-empty lines..
    if [[ ! -z "$line" ]]; then
        fname=$(echo $line | cut -d'(' -f1 | sed -e '${s/.* //}')                                                                           # function name
        rettype=$(echo $line | cut -d'(' -f1 | sed -e 's/ [^ ]*$//g' | sed -e 's/, */,/g' | sed -e 's/,/, /g' | sed -e 's/>>/> >/g')        # return type

        # strip variable names..
        params=$(echo -e $line | cut -d'(' -f2 | cut -d')' -f1)                                                                             # function params
        params=$(echo "$params" | sed -e 's/ \+/ /g')                                                                                       # '<spaces>' -> '<space>'
        params=$(echo "$params" | sed -e 's/, */,/g')                                                                                       # ', ' -> ','
        params=$(echo "$params" | sed -e 's/ [^, ]*,/,/g')                                                                                  # ' <varname>,' -> ','
        params=$(echo "$params" | sed -e 's/ [^ ]*$//g')                                                                                    # ' last-varname' -> ''
        params=$(echo "$params" | sed -e 's/>>/> >/g')                                                                                      # '>>' -> '> >'
        params=$(echo "$params" | sed -e 's/ =/=/g' | sed -e 's/= /=/g')                                                                    # ' =' -> '='  &&  '= ' -> '='
        params=$(echo "$params" | sed -e 's/[[:space:]][^ ]*=[^ ]*,/,/g')                                                                   # '   <word>=<word>,' -> ' ,'
        params=$(echo "$params" | sed -e 's/[[:space:]]*[^ ]*=[^ ]*//g')                                                                    # '   <word>=<word>' -> ''

        echo "Return: " "$rettype"
        echo "FuncName: " "$fname"


        # print each argument of function on new line..
        nargs=0
        param=""
        while IFS=',' read -ra ADDR; do
            for Item in "${ADDR[@]}"; do

                left="${param//[^<]}"                                                                                                       # extract all '<'
                right="${param//[^>]}"                                                                                                      # extract all '>'
                left_temp="${Item//[^<]}"                                                                                                   # extract all '<' from Item
                right_temp="${Item//[^>]}"                                                                                                  # extract all '>' from Item
                sum_left=$((${#left} + ${#left_temp}))                                                                                      # sum count of '<'
                sum_right=$((${#right} + ${#right_temp}))                                                                                   # sum count of '>'

                if [[ $sum_left -ne $sum_right ]]; then

                    # angle-brackets do not yet match..

                    if [[ -z "${param}" ]];then
                        param="${Item}"
                    else
                        param="${param}, ${Item}"
                    fi
                else
                    # angle-brackets match..

                    if [[ -z "${param}" ]]; then
                        param="${Item}"
                    else
                        param="${param}, ${Item}"
                    fi
                    echo "FuncArg: " "${param}"

                    ((++nargs))

                    param=""
                fi
            done
        done <<< "$params"


        # print function's parameter-list & argument-count ..
        params=$(echo "$params" | sed -e 's/,/, /g')
        echo "ParamList: ($params)"
        echo "NArgs: $nargs"
        echo
    fi

done < "$file"
